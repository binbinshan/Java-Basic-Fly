## Java 中垃圾回收机制中如何判断对象需要回收？常见的 GC 回收算法有哪些？

### Java 中垃圾回收机制中如何判断对象需要回收？
JVM判断对象是否需要被回收，主要是有两种方法:
* 引用计数法
给对象添加一个引用计数，当被引用时引用计数+1，当引用失效时，引用计数-1。当引用计数为0的时候，代表该对象可以被回收。
但是引用计数法有一个问题，就是无法解决相互依赖，两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 正因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。

* 可达性分析算
通过GC root作为起始点往下搜索，能够到达的对象都是不需要回收的，不能到达的需要被回收。
GC Root一般包含以下内容：
    * 虚拟机栈引用的对象
    * 本地方法栈引用的对象
    * 方法区中静态属性引用的对象
    * 方法区中常量引用的对象

### 常见的GC回收算法
* 标记-清除算法
将存活的对象进行标记，会被标记的会被清除
缺点：标记和清除的效率不高，且会产生大量的内存随便，导致无法创建大对象。
* 标记-整理算法
将存活的对象进行标记，然后将存活的对象移动到一端，然后把剩余的空间清除。

* 复制算法
将内存分为两块，每次只是用一块，当该块内存满了之后，就复制到另一块内存上，将该内存块进行清理。主要的缺点就是只能使用内存的一部分。
就比如Hotspot中就将新生代分为了三部分，一个Eden区和两个Survivor区，每次只使用E区和一个S区，当进行回收的时候，就会把将 Eden 和 Survivor 中还存活着的对象一次性复制到另一块 Survivor 空间上，最后清理 Eden 和使用过的那一块 Survivor。 
HotSpot 虚拟机的 Eden 和 Survivor 的大小比例默认为 8:1，保证了内存的利用率达到 90%。如果每次回收有多于 10% 的对象存活，那么一块 Survivor 空间就不够用了，此时需要依赖于老年代进行分配担保，也就是借用老年代的空间存储放不下的对象。 

* 分代回收算法
现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。 一般将堆分为新生代和老年代。 
新生代：复制算法
老年代：标记清除、标记整理