## Java 线程和操作系统的线程是怎么对应的？Java线程是怎样进行调度的?

1. java的线程共有新建New、运行Runble、阻塞Blocked、等待waiting、超时等待Timed Waiting、死亡Terminated 六种状态。
2. 操作系统中的线程只有准备reday、运行running、等待waiting 三种状态。
3. Java线程中的Timed Waiting、Waiting、Blocked，对应的都是操作系统线程的waiting（等待）状态。Java线程中的Runnable状态，则对应了操作系统中的ready和running状态。

### java线程调度
操作系统的线程模型为三种：
1. 线程实现在用户空间下
    * 需要自己实现线程的数据结构、创建销毁和调度维护。也就相当于需要实现一个自己的线程调度内核，而同时这些线程运行在操作系统的一个进程内，最后操作系统直接对进程进行调度。优点：减少了操作系统从内核态到用户态的切换开销。缺点：当一个进程中的某一个线程出现阻塞时，会阻塞整个进程。
2. 线程实现在操作系统内核中：
    * 直接使用操作系统中已经实现的线程，而线程的创建、销毁、调度和维护，都是靠操作系统（准确的说是内核）来实现，程序员只需要使用系统调用，而不需要自己设计线程的调度算法和线程对CPU资源的抢占使用。
1. 使用用户线程加轻量级进程混合实现
    * 即存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，大大降低了整个进程被完全阻塞的风险。
    
JAVA线程调度：
JDK1.2之前，是使用自己开发的一个线程调度内核，而到操作系统层面就是用户空间内的线程实现；JDK1.2及以后，JVM选择了使用操作系统原生的线程模型，通过系统调用，将程序的线程交给了操作系统内核进行调度。现在的Java中线程的本质，其实就是操作系统中的线程。