

## 简述 HashMap 的实现及常用方法的时间复杂度

HashMap不是线程安全的，键值对允许为null。
JDK1.7中，HashMap采用的数据结构为数组+链表。JDK1.8中，HashMap采用的数据结构为数组+链表/红黑二叉树。以四个方面来介绍下HashMap：

* hash算法优化：
    HashMap 把 hashCode()计算出的值进行了优化，将hash值 与 hash值右移16位的hash值进行异或，这样hash值高低位就都参与了计算。
    
* 寻址算法优化：
    HashMap没有采用常见对hash值进行取模的方式计算地址，而是采用了Hash值和(数组长度-1)进行与运算，首先两种方式的效果是一样的，这是因为HashMap中数组的长度始终是2的平方。采用与运算的原因是效率更高，

* hash碰撞解决：
    hash碰撞是因为即便进行了hash算法优化和寻址算法优化，但是还是会出现地址相同的情况，所以HashMap会采用拉链法解决，形成一个链表；当链表的长度达到一定程度的时候，就会扩展为红黑树。
    
* HashMap的扩容：
    HashMap扩容会将数组扩大为原来的两倍，并且会进行reHash。reHash需要把hash值和扩大后的数组长度-1 与运算，对运算结果判断二进制结果中是否多出一个bit的1，如果没多，那么就是原来的index，如果多了出来，那么就是index + oldCap，这样就得到了新的下标
    这里需要注意，当链表的长度到达8时，会转换为红黑树，但是这里如果当前数组小于64，就会先扩容数组。


### 常用时间复杂度
我们就以put get remove方法为例，这三个方法都涉及到查找元素：
1. 在hash算法合理的情况下，没有出现Hash冲突，此时的时间复杂度最优，为O(1)
2. 在出现Hash冲突的时候，当查询的为链表时，此时的时间复杂度为O(n)
3. 当链表进化为红黑树的时候，此时的时间复杂度为O(LogN)