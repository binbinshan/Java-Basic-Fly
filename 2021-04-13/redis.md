# 如何保证缓存数据库双写一致？

## 是否需要强一致？
也就是说如果你的系统不是严格要求 “缓存+数据库” 必须保持一致性的话，最好不要做这个方案，即：读请求和写请求串行化，串到一个内存队列里去。
串行化可以保证一定不会出现不一致的情况，但是它也会导致系统的吞吐量大幅度降低，用比正常情况下多几倍的机器去支撑线上的一个请求。

## Cache Aside Pattern
最经典的缓存+数据库读写的模式，就是 Cache Aside Pattern：
* 读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应。
* 更新的时候，先更新数据库，然后再删除缓存。

#### 为什么是删除缓存，而不是更新缓存呢？
1. 更新某个字段时，需要查询另外的数据并进行运算，才能计算出缓存最新的值的。
2. 更新缓存带来的代价更大，如果大部分都是更新缓存，而缓存访问不频繁，所以没必要更新。
3. 实现了懒加载的思想，使用到了采取加载。


## 缓存不一致问题及解决方案

#### 问题1
先更新数据库，再删除缓存。如果删除缓存失败了，那么会导致数据库中是新数据，缓存中是旧数据，数据就出现了不一致。

* 解决思路：
    
    1. 先删除缓存，再更新数据库。如果数据库更新失败了，那么数据库中是旧数据，缓存中是空的，那么数据不会不一致。因为读的时候缓存没有，所以去读了数据库中的旧数据，然后更新到缓存中。
    
    2. 延时双删策略
        1. 先淘汰缓存
        2. 再写数据库
        3. 休眠1秒，再次淘汰缓存,（这个休眠时间需要看具体业务）


#### 问题2
数据发生了变更，先删除了缓存，然后要去修改数据库，此时还没修改。一个请求过来，去读缓存，发现缓存空了，去查询数据库，查到了修改前的旧数据，放到了缓存中。随后数据变更的程序完成了数据库的修改，就产生了不一致。

* 解决方案：
    ![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-04-13/16182348542682.jpg)

    * （1）更新数据库数据
    * （2）数据库会将操作信息写入binlog日志当中
    * （3）订阅程序提取出所需要的数据以及key
    * （4）另起一段非业务代码，获得该信息
    * （5）尝试删除缓存操作，发现删除失败
    * （6）将这些信息发送至消息队列
    * （7）重新从消息队列中获得该数据，重试操作。

上述的订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能。至于oracle中，博主目前不知道有没有现成中间件可以使用。另外，重试机制，博主是采用的是消息队列的方式。如果对一致性要求不是很高，直接在程序中另起一个线程，每隔一段时间去重试即可