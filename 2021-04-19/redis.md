# Redis 如何实现分布式锁？
Redis 锁主要利用 Redis 的 setnx 命令。

* 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。
* 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
* 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。

# 锁带来的问题
1. SETNX 和 EXPIRE 非原子性
    * 如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。

    * 解决方案: 使用 lua 脚本

1. 锁误解除
    * 如果线程 A 成功获取到了锁，并且设置了过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。

    * 解决方案：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。

1. 超时解锁导致并发
    * 如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。

    * 有两种方式解决该问题：
        1. 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。
        2. 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。
1. 不可重入
    * 当线程在持有锁的情况下再次请求加锁，如果一个锁支持一个线程多次加锁，那么这个锁就是可重入的。如果一个不可重入锁被再次加锁，由于该锁已经被持有，再次加锁会失败。Redis 可通过对锁进行重入计数，加锁时加 1，解锁时减 1，当计数归 0 时释放锁。

    * 有两种方式解决该问题：
        1. 在本地记录记录重入次数，如 Java 中使用 ThreadLocal 进行重入次数统计
        2. 另一种方式是 Redis Map 数据结构来实现分布式锁，既存锁的标识也对重入次数进行计数。
