# 线程池是如何实现的？简述线程池的任务策略 

线程池主要由两部分组成，一部分是阻塞队列，另一部分是线程容器。
* 线程容器：通过添加一个Set集合来存放活跃的线程，可以通过判断工作线程的数量与核心线程数的大小，当不足时，可以开启一个新的线程去执行任务，若超出则将任务暂存在任务队列中。

* 阻塞队列：可以向阻塞队列中添加任务，根据阻塞队列是否是无界的java提供了两种不同的队列实现，一是ArrayBlockingQueue,另一是LinkedBlockingQueue。


### 任务策略
1. 线程总数量 < corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 < corePoolSize时）。注意，这一步需要获得全局锁。
2. 线程总数量 >= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。 
3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得全局锁。
4. 缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取拒绝策略进行处理。

# 线程池是如何实现的？简述线程池的任务策略 

线程池主要由两部分组成，一部分是阻塞队列，另一部分是线程容器。
* 线程容器：通过添加一个Set集合来存放活跃的线程，可以通过判断工作线程的数量与核心线程数的大小，当不足时，可以开启一个新的线程去执行任务，若超出则将任务暂存在任务队列中。

* 阻塞队列：可以向阻塞队列中添加任务，根据阻塞队列是否是无界的java提供了两种不同的队列实现，一是ArrayBlockingQueue,另一是LinkedBlockingQueue。


### 任务策略
1. 线程总数量 < corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 < corePoolSize时）。注意，这一步需要获得全局锁。
2. 线程总数量 >= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了线程复用）。 
3. 当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。注意，这一步需要获得全局锁。
4. 缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取拒绝策略进行处理。

