minor GC触发条件是年轻代中的Eden区满了。

假设单位时间T内发生一次持续25ms的minor GC，接口平均响应时间为50ms，且请求均匀到达，那么有(50ms+25ms)/T比例的请求会受GC影响。
其中GC前的50ms内到达的请求都会增加25ms；GC期间的25ms内到达的请求，会增加0-25ms不等；
如果时间T内发生N次GC，受GC影响请求占比=(接口响应时间+GC时间)×N/T 。可见无论降低单次GC时间还是降低GC次数N都可以有效减少GC对响应时间的影响。

举例说明：
Minor GC每分钟100次 ，Major GC每4分钟一次，单次Minor GC耗时25ms，单次Major GC耗时200ms，接口响应时间50ms。
（50ms+25ms）× 100次/60000ms = 12.5%，50ms × 100次/60000ms = 8.3% 。
计算可知由于Minor GC的发生，12.5%的请求响应时间会增加，其中8.3%的请求响应时间会增加25ms，


## 设置堆大小初始值

活跃数据指的是应用程序稳定运行时间长期存活对象在堆中占用的空间大小，就是full gc后堆中老年代占用空间大小。可以通过gc日志中full gc之后老年代数据大小得出。取多次gc之后数据大小的平均值。

![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-09/16205684491724.jpg)

例如，根据GC日志获得老年代的活跃数据大小为300MB，那么各分区大小可以设为： 总堆：1200MB = 300MB × 4 新生代：450MB = 300MB × 1.5 老年代： 750MB = 1200MB - 450MB*

## 增加Eden区大小
通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor GC，因此可以通过增大新生代空间来降低Minor GC的频率。在相同的内存分配率的前提下，新生代中的Eden区增加一倍，Minor GC的次数就会减少一半。
扩容后，Minor GC时增加了T1（扫描时间），但省去T2（复制对象）的时间，更重要的是对于虚拟机来说，复制对象的成本要远高于扫描成本，所以，单次Minor GC时间更多取决于GC后存活对象的数量，而非Eden区的大小。因此如果堆中短期对象很多，那么扩容新生代，单次Minor GC时间不会显著增加。
服务中存在大量短期临时对象，扩容新生代空间后，Minor GC频率降低，对象在新生代得到充分回收，只有生命周期长的对象才进入老年代。这样老年代增速变慢，Major GC频率自然也会降低。
