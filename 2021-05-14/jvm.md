# JVM的类加载机制

一个类的生命周期 : 加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载


我们知道 .Java 文件打包会编译成 .Class 文件，然后由类加载器加载到JVM中。那么类加载机制是怎样的？

### 1、什么时候会加载一个类到JVM中？（对应 加载）
简单的来说，就是在JVM中需要用到这类的时候就加载。

![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-14/16208945413080.jpg)

如上图，现在有一个 ClassLoad 类，里面有一个main()，那么JVM进程启动后，一定会把main() 方法的主类 ClassLoad 这个类加载到内存中，然后从main()开始执行。
在main()方法中，还有一个 Users 对象，那么这个时候就需要把UserS类给加载到内存中，然后创建实例对象供使用。所以此时就会把Users对应的 .Class文件给加载到JVM中。

### 2、验证 -> 准备 -> 解析都做了什么？
1. 验证：这一步就是根据Java虚拟机规范，来校验你加载进来的“.class”文件中的内容，是否符合指定的规范，如果不符合规范，那你让JVM情何以堪怎么去执行呢。

2. 准备：其实就是给这个ClassLoad 类分配一定的内存空间,然后给他里面的类变量 ans（也就是static修饰的变量）分配内存空间，来一个默认的初始值，也就是0。
    ![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-14/16208951423512.jpg)

1. 解析：实际上是把符号引用替换为直接引用的过程

需要重点关注的是准备阶段。因为这个阶段是给加载进来的类分配好了内存空间，类变量也分配好了内存空间，并且给了默认的初始值，这个概念，大家心里一定要 有。


### 3、初始化 做了什么？
在准备阶段，我们给 ClassLoad 类分配了内存空间,然后给他的类变量 ans 分配内存空间，给了一个默认值0。初始化阶段，就是会正式执行 类初始化 的代码。

#### 3.1 什么是类初始化代码？
![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-14/16208961128623.jpg)

上面准备 阶段会给ans 附上一个 0 值，而这个 100 则是在 初始化阶段才会赋值给 ans的，
另外，静态代码块也会在 初始化阶段 执行。

#### 3.2 什么时候会初始化一个类？
讨论几个常见的情况：
1. 比如 通过 “new ClassLoad()” 创建实例的时候，会初始化。
2. 操作一个类的静态变量或者静态方法。
3. 包含 “main()” 方法的主类，必须是立马初始化的。
4. 如果初始化一个类的时候，发现他的父类还没初始化，那么必须先初始化他的父类
5. 反射

### 4、类加载器和双亲委派机制
上面讨论了从 加载到初始化 的过程，现在来讨论 类加载器。


1. 启动类加载器（Bootstrap ClassLoader） ：
    * 主要是负责加载我们在机器上安装的Java目录下的核心类的。在Java安装目录下，就有一个“lib”目录，这里就有Java最核心的一些类库。所以一旦JVM启动，那么首先就会依托启动类加载器，去加载Java安装目录下的“lib”目录中的核心类库。

2. 扩展类加载器 （Extension ClassLoader）：
    * 这个类加载器其实也是类似的，Java安装目录下有一个“lib\ext”目录，这里面有一些类，就是需要使用这个类加载器来加载的，支撑系统的运行。JVM一旦启动，也会去加载lib\ext下的类。

3. 应用程序类加载器 （Application ClassLoader）：
    * 这类加载器就负责去加载“ClassPath”环境变量所指定的路径中的类，大致可以理解为我们自己写的Java代码，这个类加载器就负责加载那些类到内存里。

1. 自定义类加载器 ：
    * 我们自己去实现一个类加载器，比如可以做到 隔离加载类 、源码加密等。


##### 双亲委派机制 : 先找父亲去加载，不行的话再由儿子来加载，可以避免多层级的加载器结构重复加载某些类。
![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-14/16208978308887.jpg)
我们刚才讨论了类加载器，其实他们之间是有层级结构，如上图。

假设你的应用程序类加载器需要加载一个类，他首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载，但是如果父类加载器在自己负责加载的范围内，没找到这个类，那么就会下推加载权利给自己的子类加载器。


### 5、Tomcat的类加载机制是怎样的？
Tomcat本身就是用Java写的，那么就肯定要用到类加载机制，我们来讨论下它的实现原理；

![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-14/16208980899293.jpg)

从上图我们可以得知Tomcat自定义了 Common、Catalina、Shared 、WebApp 、Jsp 类加载器。

其中 Common、Catalina、Shared等类加载器，其实就是用来加载Tomcat自己的一些核心基础类库的。

而WebApp类加载器，每个部署在里面的Web应用都有一个对应的WebApp类加载器，负责加载部署的这个Web应用的类。至于Jsp类加载器，则是给每个JSP都准备了一个Jsp类加载器。 

重点是 ，Tomcat是打破了双亲委派机制的，每个WebApp负责加载自己对应的那个Web应用的class文件，也就是我们写好的打包好的war包中的所有class文件，不会传导给上层类加载器去加载。
