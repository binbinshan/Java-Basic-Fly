# 深入垃圾回收器（二） - G1

### 1、入门G1
* 为什么需要G1？
我们之前分析了 ParNew + CMS，最大的问题就是“Stop the World”。所以对垃圾回收器的优化，都是朝着减少“Stop the World”的目标去做的。
而G1垃圾回收器可以提供比“ParNew + CMS”组合更好的垃圾回收的性能。

* 什么是G1？
G1垃圾回收器是可以同时回收新生代和老年代的对象的，不再需要两个垃圾回收器配合起来运作。
    * 特点一：就是把Java堆内存拆分为多个大小相等的Region
    一个Region可能有时候属于新生代，有时候属于老年代，并不是一成不变的。实际上新生代和老年代各自的内存区域是不停的变动的，由G1自动控制。
![-w248](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-18/16210829959947.jpg)

 * 特点二：允许设置一个垃圾回收的预期停顿时间
    比如，在1小时内由G1垃圾回收导致的“Stop the World”时间， 也就是系统停顿的时间，不能超过1分钟。


### 2、G1是如何做到对垃圾回收导致的系统停顿可控的？
G1如果要做到这一点，他就必须要追踪每个Region里的回收价值，啥叫做回收价值呢？

回收价值就是必须搞清楚每个Region里的对象有多少是垃圾，如果对这个Region进行垃圾回收，需要耗费多长时间，可以回收掉多少垃圾？

G1可以做到让你来设定垃圾回收对系统的影响，他自己通过把内存拆分为大量小Region，以及追踪每个Region中可以 回收的对象大小和预估时间，最后在垃圾回收的时候，尽量把垃圾回收对系统造成的影响控制在你指定的时间范围内，同时在有限的时 间内尽量回收尽可能多的垃圾对象。

### 3、深入G1的Region
* 到底有多少个Region呢？每个Region的大小是多大呢？

   通过使用“-XX:+UseG1GC”来指定使用G1垃圾回收器，JVM启动的时候一旦发现使用的是G1垃圾回收器，因为JVM最多可以有2048个Region，然后Region的大小必须是2的倍数，比如说1MB、2MB、4MB之类的。所以会自动用 堆大小除以2048 算出每个Region的大小。
    
   假设使用“-Xms”和“-Xmx”来设置堆内存的大小为4G，也就是 4096MB 除以 2048个Region，每个Region的大小就是2MB。


* 还有新生代和老年代吗？

  在G1中虽然把内存划分为了很多的 Region，但是其实还是有新生代、老年代的区分。
  
  刚开始的时候，默认新生代对堆内存的占比是5%，对应大概是100个Region，可以通过“XX:G1NewSizePercent”来设置新生代初始占比的，其实维持这个默认值即可。
  
  在系统运行中，JVM其实会不停的给新生代增加更多的Region，但是最多新生代的占比不会超过60%，可以通过“XX:G1MaxNewSizePercent”设置比例。
  
  而且一旦Region进行了垃圾回收，此时新生代的Region数量还会减少，这些其实都是动态的。
  
* 新生代还有Eden和Survivor吗？

  新生代里还是有Eden和Survivor的划分的，通过“-XX:SurvivorRatio=8”这个参数，根据这个参数，假设有100个Region，那么可能80个Region就是Eden，两个Survivor各自占10个Region。
  
  他们会各自占据不同的Region。过随着对象不停的在新生代里分配，属于新生代的Region会不断增加，Eden和Survivor对应的Region也会不断增加。

* 大对象Region
    之前我们讨论过，大对象直接进入老年代，但是G1提供了专门的Region来存放大对象，而不是让大对象进入老年代的Region中。大对象的判定规则就是一个大对象超过了一个Region大小的50%，就会被放入大对象专门的Region中。而且一个大对象如果太大，可能会横跨多个Region来存放。
    新生代、老年代在回收的时候，会顺带带着大对象Region一起回收。
    
### 4、G1的新生代垃圾回收
G1的新生代也有Eden和Survivor的区分，那么触发垃圾回收的机制都是类似的。

* 随着不停的在新生代的Eden对应的Region中放对象，JVM就会不停的给新生代加入更多的Region，直到新生代占据堆大小的最大比例 60%。  

* 一旦新生代达到了设定的占据堆内存的最大大小60%，比如都有1200个Region了，里面的Eden可能占据了1000个Region，每个 Survivor是100个Region，而且Eden区还占满了对象

* 触发新生代的GC，G1就会用之前说过的复制算法来进行垃圾回收，进入一个“Stop the World”状态，把Eden对应的Region中的存活对象放入S1对应的Region中，接着回收掉Eden对应的Region中的垃圾对象

* 因为G1是可以设定目标GC停顿时间的，可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms。那么G1就会通过之前说的，对每个Region追踪回收他需要多少时间，可以回收多少对象来选择回收一部分的Region，保证GC停顿时 间控制在指定范围内，尽可能多的回收掉一些对象。

### 5、对象什么时候进入老年代？
  按照默认新生代最多只能占据堆内存60%的Region来推算，老年代最多可以占据40%的Region，大概就是800个左右的Region。
那么对象什么时候从新生代进入老年代呢？
1. 对象在新生代躲过了很多次的垃圾回收，达到了一定的年龄了，进入老年代

2. 动态年龄判定规则，如果一旦发现某次新生代GC过后，存活对象超过了Survivor的50%。
比如年龄为1岁，2岁，3岁，4岁的对象的大小总和超过了Survivor的50%，此时4岁以上的对象全部会进入老年 代，这就是动态年龄判定规则

和之前我们讨论的是相同的。


### 6、什么时候触发新生代+老年代的混合垃圾回收？ 
G1有一个参数，是“-XX:InitiatingHeapOccupancyPercent”，他的默认值是45%，如果老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。堆内存有2048个Region，如果老年代占据了其中45%的Region，也就是接近1000个Region的时候，就会开 始触发一个混合回收

### 7、G1垃圾回收的过程
初始标记：
* 首先会触发一个“初始标记”的操作，这个过程是需要进入“Stop the World”的，仅仅只是标记一下GC Roots直接能引用的对象， 这个过程速度是很快的。

并发标记：
* 接着会进入“并发标记”的阶段，这个阶段会允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，这个并发标记阶段还是很耗时的，因为要追踪全部的存活对象。但是这个阶段是可以跟系统程序并发运行的，所以对系统程序的影响不太大。

最终标记：
* 最终标记阶段，这个阶段会进入“Stop the World”，系统程序是禁止运行的，但是会根据并发标记 阶段记录的 那些对象修改，最终标记一下有哪些存活对象，有哪些是垃圾对象

混合回收：
* 最后一个阶段，就是“混合回收“阶段，这个阶段会计算老年代中每个Region中的存活对象数量，存活对象的占比，还有执行垃圾回 收的预期性能和效率。比如说老年代此时有1000个Region都满了，但是因为根据预定目标，本次垃圾回收可能只能停顿200毫秒，那么通过之前的计算得 知，可能回收其中800个Region刚好需要200ms，那么就只会回收800个Region，把GC导致的停顿时间控制在我们指定的范围内。

当老年代对堆内存占比达到45%的时候，触发的是“混合回收”，也就是说，此时垃圾回收不仅仅是回收老年代，还会回收新生代，还会回收大对象。

当新生代达到了设定的占据堆内存的最大大小60%，Eden区还占满了对象，就会触发新生代回收。

### 8、G1垃圾回收器参数

-XX:G1MixedGCCountTarget：
* 在一次混合回收的过程中，最后一个阶段执行几次混合 回收，默认值是8次。意思是最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反 复8次。

* 可以尽可能让系统不要停顿时间过长。

-XX:G1HeapWastePercent：
* 默认值是5%，在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会 立即停止混合回收。

* 来G1整体是基于复制算法进行Region垃圾回收的，不会出现内存碎片的问题，不需要像CMS那样标记-清理之 后，再进行内存碎片的整理。


-XX:G1MixedGCLiveThresholdPercent：
* 默认值是85%，意思就是确定要回收的Region的时候，必须是存活对象低于85%的Region才可以进行回收，
* 要是一个Region的存活对象多余85%，这个时候要把85%的对象都拷贝到别的Region，这个成本是很高的。


### 9、回收失败时的Full GC
如果在进行Mixed回收的时候，无论是年轻代还是老年代都基于复制算法进行回收，都要把各个Region的存活对象拷贝到别的Region 里去，此时万一出现拷贝的过程中发现没有空闲Region可以承载自己的存活对象了，就会触发 一次失败。
一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，这个过程是极慢极慢 的。