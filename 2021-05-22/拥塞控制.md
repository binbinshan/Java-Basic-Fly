# TCP的拥塞控制是怎么实现的？
![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-22/16215921392797.jpg)
拥塞控制主要由四个算法组成：慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）。

1. 慢启动：刚开始发送数据时，先把拥塞窗口（cwnd）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍。
![-w579](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-22/16215922966649.jpg)
1. 拥塞避免：当拥塞窗口的大小达到慢开始门限(ssthresh)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS。
    无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。（这是不使用快重传的情况）

1. 快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。
  ![-w609](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-05-22/16215927001804.jpg)

    
1. 快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。
    1. 不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 * MSS 。
    2. 这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。

