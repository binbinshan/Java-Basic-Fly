# MySQL物理数据模型(四)


* 数据页
InnoDB的数据页有很多种，比如，索引页，Undo页，Inode页，系统页，BloB页等。这里是最常见的索引页分析。
![-w281](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-06-08/16229800500226.jpg)

    * 文件头 ： 占用38个字节，存储表空间相关的信息，例如：
        * 数据页在文件中的起始偏移量
        * 前一个数据页和后一个数据页的指针
        * 当前数据页最新被修改的lsn等

    * 数据页头：占用56个字节，这部分才是存的数据页相关的元信息，例如：
        * 数据页中数据页目录的个数
        * 数据页中的空闲空间的起始地址
        * 当前数据页中用户的记录数
        * 这个页是否是B树中的叶子节点
        * 修改此数据页的当前最大事务id等

    * 最大最小记录：占用26个字节
        * 最大记录是这个数据页中逻辑上最大的记录，所有用户的记录都小于它。最小记录是数据页上最小的记录，所有用户记录都大于它。他们在数据页被创建的时候创建，而且不能被删除。引入他们主要是方便页内操作。

        
    * 多个数据行
        * 用户所有插入的记录都存放在这里，记录按照主键顺序排序。每个记录都有指向下一个记录的指针。
        * 默认情况下记录跟记录之间没有间隙，但是如果重用了已删除记录的空间，就会导致空间碎片。

    * 空闲区域：
        * 从数据页中的空闲空间的起始地址开始，到最后一个数据目录，这之间的空间就是空闲空间，都被重置为0，当用户需要插入记录时候，首先在被删除的记录的空间中查找，如果没有找到合适的空间，就从这里分配。
        
    * 数据页目录：
        * 存储数据页的目录，用来加速查找。注意这个目录是稀疏的，即不是所有的记录在目录都有索引，平均是每隔六个记录才有一个目录。
        
    * 数据页尾部：占用8个字节
        * 低地址的四个字节存储checksum的值，高地址的四个字节存储当前数据页最新被修改的lsn的低位四字节。


* 表空间 
当我们需要 执行crud 操作时，就是从磁盘上的表空间的数据文件里，去加载一些数据页出来到Buffer Pool的缓存页里去使用。
从外部来看，表空间是由连续的固定大小page构成。其实表空间文件内部还是组织为更复杂的逻辑结构，自顶向下可分为segment、extent和page。

    * segment：
        * 表空间下一级称为segment。segment与数据库中的索引相映射。Innodb引擎内，每个索引对应两个segment：管理叶子节点的segment和管理非叶子节点segment。创建索引中很关键的步骤便是分配segment，Innodb内部使用INODE来描述segment。
    * extent(数据区)：
        * segment的下一级是extent，extent代表一组连续的page，默认为64个page，大小1MB。extent的作用是提高page分配效率。Innodb内部使用XDES来描述extent。
        * 在表空间里有很多组数据区，一组数据区是256个数据区，每个数据区包含了64个数据页，是1mb

    * page(数据页):
        * 表空间数据存储的基本单位。


* 总结：
  
  插入一条记录的流程：
  1. 根据要插入的记录的表，找到对应的表空间
  2. 找到表空间中对应的数据区组，然后在找到对应的数据区
  3. 从数据区中找到一个数据页
  4. 将数据页加载到Buffer Poll中
  5. 进行插入数据到数据页的数据行中
  6. 把修改的缓存页加入flush链表
  7. 刷新脏页到磁盘上

  查询一条记录的流程：
  1. 通过随机读写的方式，指定开始读取位置和结束位置
  2. 找到对应的数据页
  3. 加载数据页到Buffer Poll中

  

