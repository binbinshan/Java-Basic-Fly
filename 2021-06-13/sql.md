# MySQL中的隔离级别与实现(八)
MySQL 事务都是指在 InnoDB 引擎下，MyISAM 引擎是不支持事务的。
数据库事务的 ACID 四大特性是事务的基础：
* A (Atomicity  原子性)
    * 原子性：事务就是一系列的操作，要么全部都执行，要么全都不执行；

    * 如果不具备原子性，无法保证全部执行或全不执行，那么就会造成数据库不可信且不可用。

    * MySQL中使用undo log日志实现原子性。
    
* C (Consistency  一致性)
    * 如果一个事务原子地在一个一致地数据库中独立运行，那么在它执行之后，数据库的状态一定是一致的
    

* I (Isolation  隔离性)
    * 隔离性：多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

    * 事务隔离级别：读未提交、读已提交、可重复读、串行化
    * 事务问题：脏读、不可重复读、幻读

* D (Durability  持久性)
    * 持久性：一旦事务被提交，数据一定会被写入到数据库中并持久存储起来。

    * MySQL使用重做日志（redo log）实现事务的持久性


### MySQL中的隔离性
上面我们讨论了数据库的事务基础，现在我们再来展开讨论下事务的隔离性。

#### 事务隔离性要解决的问题
首先先来看下事务隔离性要解决的问题：
* 脏读：脏读指的是读到了其他事务未提交的数据，未提交意味着这些数据可能会回滚，也就是可能最终不会存到数据库中，也就是不存在的数据。读到了并一定最终存在的数据，这就是脏读。

* 不可重复读：指的是在同一事务内，不同的时刻读到的同一批数据可能是不一样的，可能会受到其他事务的影响，比如其他事务改了这批数据并提交了。通常针对数据更新（UPDATE）操作。

* 幻读：幻读是针对数据插入（INSERT）操作来说的。在一个事务中，同一个范围内的记录被读取时，其他事务向这个范围添加了新的记录。

##### MySQL的事务隔离级别
SQL 标准定义了四种隔离级别，MySQL 全都支持。这四种隔离级别分别是：
1. 读未提交（READ UNCOMMITTED）RU ：使用查询语句不会加锁，可能会读到未提交的行

3. 读提交 （READ COMMITTED）RC ：只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果
4. 可重复读 （REPEATABLE READ）RR ：多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读
5. 串行化 （SERIALIZABLE）：InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；

从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中，可重复读是 MySQL 的默认级别。
事务隔离其实就是为了解决上面提到的脏读、不可重复读、幻读这几个问题，下面展示了 4 种隔离级别对这三个问题的解决程度。
![](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-06-13/16231405122174.jpg)

### MySQL 中是如何实现事务隔离的
1. 读未提交：性能最好，什么锁也不加，可以理解为没有隔离。

2. 串行化：读的时候加共享锁，也就是其他事务可以并发读，但是不能写。写的时候加排它锁，其他事务不能并发写也不能并发读。

#### ReadView与undo log版本链

在解释RC和RR的实现原理之前，需要先了解下什么是undo log版本链，什么是ReadView。

##### undo log版本链
undo log是用来保证原子性，回滚的时候用的，这里就不详细展开了，另外之前我们也讨论了一条数据在数据页中的存储格式，其中每行数据都有两个隐藏字段DB_TRX_ID和DB_ROLL_PTR。
DB_TRX_ID 标识最新更改事务的ID，DB_ROLL_PTR则是指向了更新这个事务之前生成的undo log。
我们以一个例子来帮助理解下：
![-w563](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-06-13/16231478469212.jpg)
1. 事务A 先插入一条数据 值A，此时这条记录的事务ID是30，db_roll_ptr则指向了null。
2. 事务B 对这条数据修改为 值B，此时这条记录的事务ID是31，db_roll_ptr则指向了之前的 值A 的undo log。
3. 事务C 对这条数据修改为 值C，此时这条记录的事务ID是32，db_roll_ptr则指向了之前的 值B 的undo log。

通过这样一个例子，可以知道修改了一行数据，都会更新隐藏字段txr_id和db_roll_ptr，同时之前多个数据快照对应的undo log，会通过db_roll_ptr指针串联起来，形成一个版本链。

##### ReadView机制
ReadView机制就是在某一时刻给事务打快照，把当时事务状态记下来，之后的所有读操作根据其事务ID（即trx_id）与快照中的事务的状态作比较，以此判断ReadView对于事务的可见性。ReadView机制就是基于undo log多版本链条实现。

ReadView中保存的事务状态主要包括：
* m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表，也就是有哪些事务在MySQL里执行还没提交的。

* min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。
* max_trx_id：表示生成ReadView时系统中下一个要生成的事务id。（注意max_trx_id并不是m_ids中的最大值，事务id是递增分配的。假设现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1，max_trx_id的值就是4。）

* creator_trx_id：表示生成该ReadView的事务的事务id，也就是当前的事务ID。


判断规则：有了这个ReadView，这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：
* 如果被访问版本的trx_id = ReadView中的creator_trx_id ，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。

* 如果被访问版本的trx_id < ReadView中的min_trx_id，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。

* 如果被访问版本的trx_id >= ReadView中的max_trx_id，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。

* 如果被访问版本的trx_id在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下trx_id属性值是不是在m_ids列表中。
    * 如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问；
    * 如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。

总结上述规则，就是：
1. 当前事务内的更新，可以读到；
2. 版本未提交，不能读到；
3. 版本已提交，但是却在快照创建后提交的，不能读到；
4. 版本已提交，且是在快照创建前提交的，可以读到；

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本。如果最后一个版本也不可见的话，那么就意味着该条记录对该事务完全不可见，查询结果就不包含该记录。


在MySQL中，RC和RR隔离级别的的一个非常大的区别就是它们生成ReadView的时机不同。
#### 读已提交(RC)实现原理
* RC:每次读取数据前都生成一个ReadView

#### 可重复读(RR)实现原理
* RR:在第一次读取数据时生成一个ReadView


上面介绍了事务的实现机制，那么关于RR是否解决了幻读这个问题，再熟悉完锁之后，在后续讨论中继续。

