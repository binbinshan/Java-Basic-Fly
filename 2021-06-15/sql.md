# MySQL中的锁(九)

### 悲观锁和乐观锁
锁的种类一般分为乐观锁和悲观锁，而在innoDB中使用的就是悲观锁。而按照锁的粒度划分，也可以分成行锁和表锁。

乐观锁和悲观锁其实都是并发控制的机制，同时它们在原理上就有着本质的差别；
* 乐观锁是一种思想，它其实并不是一种真正的『锁』，它会先尝试对资源进行修改，在写回时判断资源是否进行了改变，如果没有发生改变就会写回，否则就会进行重试，在整个的执行过程中其实都没有对数据库进行加锁；

* 悲观锁就是一种真正的锁了，它会在获取资源前对资源进行加锁，确保同一时刻只有有限的线程能够访问该资源，其他想要尝试获取资源的操作都会进入等待状态，直到该线程完成了对资源的操作并且释放了锁后，其他线程才能重新操作资源；

乐观锁不会存在死锁的问题，但是由于更新后验证，所以当冲突频率和重试成本较高时更推荐使用悲观锁，而需要非常高的响应速度并且并发量非常大的时候使用乐观锁就能较好的解决问题。

### 锁的种类
InnoDB中关于锁的种类分为两类：
* 共享锁（Shared Lock）S：允许事务对一条行数据进行读取
    * 串行化级别下会为读加共享锁，其他隔离级别下使用select .... lock in share mode 为读加共享锁。
* 互斥锁（Exclusive Lock）X：允许事务对一条行数据进行删除或更新；
    * 在RR级别下，InnoDB会自动增删改操作的行加排他锁，也可以使用select ... for update 为读加排他锁。

如果事务 T1 持有行 r 的 s 锁，那么另一个事务 T2 请求 r 的锁时，会做如下处理：
* T2 请求 s 锁立即被允许，结果 T1 T2 都持有 r 行的 s 锁
* T2 请求 x 锁不能被立即允许

如果 T1 持有 r 的 x 锁，那么 T2 请求 r 的 x、s 锁都不能被立即允许，T2 必须等待T1释放 x 锁才行。

下图是锁的互斥关系：
![-w1052](https://github.com/binbinshan/Java-Basic-Fly/blob/master/2021-06-15/16232046524345.jpg)
共享锁代表了读操作、互斥锁代表了写操作，所以我们可以在数据库中并行读，但是只能串行写，只有这样才能保证不会发生线程竞争，实现线程安全。

### 锁的粒度
共享锁还是互斥锁其实都只是对某一个数据行进行加锁，InnoDB 支持多种粒度的锁，也就是行锁和表锁；为了支持多粒度锁定，InnoDB 存储引擎引入了意向锁（Intention Lock），意向锁就是一种表级锁。
意向锁也分为两种：
* 意向共享锁：事务想要在获得表中某些记录的共享锁，需要在表上先加意向共享锁；
* 意向互斥锁：事务想要在获得表中某些记录的互斥锁，需要在表上先加意向互斥锁；

意向锁其实不会阻塞全表扫描之外的任何请求，它们的主要目的是为了表示是否有人请求锁定表中的某一行数据。
如果没有意向锁，当已经有人使用行锁对表中的某一行进行修改时，如果另外一个请求要对全表进行修改，那么就需要对所有的行是否被锁定进行扫描，在这种情况下，效率是非常低的；不过，在引入意向锁之后，当有人使用行锁对表中的某一行进行修改之前，会先为表添加意向互斥锁（IX），再为行记录添加互斥锁（X），在这时如果有人尝试对全表进行修改就不需要判断表中的每一行数据是否被加锁了，只需要通过等待意向互斥锁被释放就可以了。

### 锁的算法

#### Record Lock
记录锁（Record Lock）是加到索引记录上的锁。通过聚簇索引或二级索引查找时，会在索引上加Record Lock。举个例子：
```
现在有一张表
CREATE TABLE users(
    id INT NOT NULL AUTO_INCREMENT,
    last_name VARCHAR(255) NOT NULL,
    first_name VARCHAR(255),
    PRIMARY KEY(id),
    KEY(last_name)
);
```
如果我们使用 id 或者 last_name 作为 SQL 中 WHERE 语句的过滤条件，那么 InnoDB 就可以通过索引建立的 B+ 树找到行记录并添加锁用来阻止其他所有事务插入、修改或者删除；
但是如果使用 first_name 作为过滤条件时，由于 InnoDB 不知道待修改的记录具体存放的位置，也无法对将要修改哪条记录提前做出判断就会锁定整个表。

#### Gap Lock
间隙锁（gap）是索引记录之间上的锁。间隙锁是性能与并发的部分折中，并只适用于一些事务隔离级别。

例如，SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE; 就会阻止其他事务插入 t.c1 = 15 的记录，不管是否已经有这种值在本列中，因为这个范围内的所有值都被上锁了。

使用唯一索引的时候用不上间隙锁。例如，id 列有唯一索引，下面的语句只是用索引记录锁（针对id=100的行）不管其他会话是否在前面的间隙中插入行。
SELECT * FROM child WHERE id = 100;
如果id列没有索引或者是非唯一索引，那么这条语句的就会锁住前面的间隙。

#### Next-Key Lock
Next-Key Locks （简称 NK 锁）是记录锁和记录前的间隙锁的结合，是一个索引记录锁加上一个在索引记录之前的间隙上的间隙锁。

在搜索唯一索引情况下会降级为RecordLock提高并发能力

```
+------|-------------|--------------|-------+
|   id | last_name   | first_name   |   age |
|------|-------------|--------------|-------|
|    4 | stark       | tony         |    21 |
|    1 | tom         | hiddleston   |    30 |
|    3 | morgan      | freeman      |    40 |
|    5 | jeff        | dean         |    50 |
|    2 | donald      | trump        |    80 |
+------|-------------|--------------|-------+

如果使用 Next-Key 锁，那么 Next-Key 锁就可以在需要的时候锁定以下的范围：
(-∞, 21]
(21, 30]
(30, 40]
(40, 50]
(50, 80]
(80, ∞)

Next-Key 锁锁定的是当前值和前面的范围。
```

当我们更新一条记录，比如 SELECT * FROM users WHERE age = 30 FOR UPDATE;，InnoDB 不仅会在范围 (21, 30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30, 40] 加间隙锁，所以插入 (21, 40] 范围内的记录都会被锁定。

默认情况下，Innodb 是可重读隔离级别，这样的话，Innodb使用NK 锁来进行索引搜索和扫描，阻止了幻读。

### 死锁的发生

##### 死锁的情况：
A事务中：
```
//加了 s 锁
SELECT * FROM t WHERE i = 1 FOR SHARE;
```
B事务中：
```
//会加上 x 锁
DELETE FROM t WHERE i = 1;
```
此时B事务会等待A事务提交，因为s锁和x锁是互斥的。

A事务中又执行了：
```
DELETE FROM t WHERE i = 1;
//此时会返回错误信息：
Deadlock found when trying to get lock; 试图锁定时发现死锁;
```

##### 死锁检测
死锁检测是一个MySQL Server层的自动检测机制，可以及时发现两个或者多个session间互斥资源的申请造成的死锁，且会自动回滚一个（或多个）事物代价相对较小的session，让执行代价最大的先执行。该参数默认就是打开的。

如果关闭了死锁检测机制，会根据innodb_lock_wait_timeout，该参数指定了“锁申请时候的最长等待时间”，当发生锁等待超时时，回滚当前语句 （不是整个事务）。

##### 死锁优化
1. 减少代码层面并发
2. 减少大事务的出现
3. 减少锁时间长的在事务前面


