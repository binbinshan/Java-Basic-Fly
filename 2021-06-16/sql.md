# MySQL中的索引(十一)


### 索引实现
探讨一下索引实现的可行方式
##### 数组
如果针对索引的操作只是精确查询或者范围查询的话，那么使用数组就够了，通过二分查找时间复杂度是O(logn)。但是如果还需要插入索引的话，那么因为数组的有序性，就需要O(n)的时间复杂度才能插入。

##### 二叉搜索树
由于O(n)的插入复杂度，可以考虑使用二叉搜索树，这样查询、插入等操作的时间复杂度就是O(logn),也就是操作Logn次的I/O操作才能取出数据。但是二叉搜索树有一个问题，就是范围查询很慢，需要不断的从根节点出发，进行搜索，所以可以进行优化数据只保存在叶子节点上，并使用双向链表连接，这样就不用每次都从根节点出发了。

##### B+树
二叉搜索树在数据量大的时候，树的高度太高了，比如高为10的的BST，就需要10次I/O操作，所以继续优化的话，就是让树变的矮胖，变成“多叉搜索树”。这个就是B+ Tree.

B Tree 和 B+ Tree都是多叉搜索树，但是两者有以下几个区别：
1. B树的节点即保存数据也保存索引，而B+树只有叶子节点保存索引和数据，其余节点只保存索引。
2. 范围查询：B树进行范围查询的时候，只能通过父节点和子节点进行连接，那么就必须不断回溯，会产生很多I/O操作。而B+ 树因为叶子节点之间通过双向链表连接，可以使用前后指正就可以查出所有数据。
3. B+树的检索效率稳定，任何查找都是从根节点到叶子节点的过程。


### 聚簇索引和非聚簇索引
聚簇索引：innndb存储引擎是要求表必须有主键的，然后会根据这个主键创建一个默认索引，这个索引中叶子节点的值就是主键key所在行的数据(数据和索引是一个文件)。当没有指定主键的时候，Mysql会默认生成一个隐藏的主键。

非聚簇索引(二级索引)：是指对某个非主键的字段创建索引，该索引中叶子结点存的值就是主键的值，需要根据主键再去聚簇索引中根据key查询到数据。

这里就会有个问题：
> 当使用非聚簇索引的时候，这时查询得到的值是主键，然后再根据主键去查询聚簇索引，这个过程称为回表查询。
> 当然也不是绝对的，当一个索引包含了所有需要查询的字段的值，就称之为“覆盖索引”。这时就不需要回表查询了。

### 覆盖索引
覆盖索引不是一种索引，是一种基于索引查询的方式。
上面我们提到了当一个索引包含了所有需要查询的字段的值(select 后面的)，就称之为“覆盖索引”。这时就不需要回表查询了。
比如 a,b 两个字段建立联合索引，当执行 SELECT a,b FROM student WHERE a = '10'；时，就不需要回表，在联合索引树上找到对应索引，此时节点索引里包含信息a,b，直接返回即可。


### 普通索引和唯一索引

对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一个不满足k=5条件的记录。

对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检索。

上面的查询区别对于性能而言是微乎其微的，InnoDB读写数据是按页来的，也是说当找到k=5的记录的时候，它所在的数据⻚就都在内存里了，那么我们只需要判断下一条数据是不是等于5即可，直到出现不为5的值为止，这些都是在内存中操作的，所以性能微乎其微。



### 联合索引
比如对(a,b,c)三个字段加联合索引，那么这个联合索引也会单独的占有一棵B+Tree，其组织方式也是有序的，其实就是按照索引定义的顺序进行排序，首先用 a 从小到大排序，若两条数据的a 相同，则使用 b 从小到大 的方式进行排序。

如果我们建立了(a,b,c) 这三个字段的联合索引以后，其实就相当于有了(a)、(a,b) 以及(a,b,c) 这三个索引，不需要再去为字段额外的添加索引了。

### 索引使用规则

##### 等值匹配规则
如果在where语句中，几个字段和联合索引中的字段一致，且都是等号的等值匹配，即使where中的字段顺序和索引顺序不一致，也是会用上索引的。

##### 最左侧列匹配
比如联合索引(a,b,c)，那么不一定必须要在where语句里根据三个字段来查，其实只要根据最左侧的部分字段来查，也是可以的。
例如：
```
select * from table where a='' and b='' //会走索引
select * from table where b=''  //不会走索引，联合索引必须从最左侧开始
select * from table where a='' and c=''  //a会先走索引过滤掉一部分数据，c不走索引。
```
##### 最左前缀匹配原则
还是联合索引(a,b,c)，这个规则只针对索引中的第一个字段有效。
```
select * from table where a like '1%' //可以走索引

因为联合索引(a,b,c)的B+树里，都是按照a排序的，所以出a的确定的最左前缀就是1，然后后面的给一个模糊匹配符号，那也是可以基于索引来查找的。
如果 a like '%1'，在左侧用一个模糊匹配符，那么就不走索引。
```

##### 范围查找规则
where语句里如果有范围查询，那只有对联合索引里最左侧的列进行范围查询才能用到索引。
```
select * from table where a < '100' and a > '10' ; //走索引
select * from table where a < '100' and a > '10' and b > '10 '; //a 走索引 b不走索引
```

##### 等值匹配+范围匹配的规则
上面范围查找规则中，指出了只有对联合索引里最左侧的列进行范围查询才能用到索引，但是这个话其实有点绝对了，比如下面：
```
select * from table where a = '10' and b > '1' and c > '2' ;
//这个sql中，a是等值匹配且是最左匹配 肯定是走索引的，
//然后查询出一些数据，在这些数据中是按联合索引的第二个索引 b排序的，所以b符合范围查找规则，可以走索引.（可以看上面联合索引小段内容）
//但是c不符合,不走索引。
```

尽可能就是从联合索引最左侧的字段开始去使用，就能用上索引树。


##### order by和group by
group by和order by用上索引的原理和条件都是差不多的，本质都是在group by 和order by之后的字段顺序和联合索引中的从最左侧开始的字段顺序一致，然后就可以充分利用索引树 里已经完成排序的特性，快速的根据排序好的数据执行后续操作了。
```
因为联合索引里的字段值在索引树里都是从小到大依次排列的,比如(a,b,c),就是先按a排序，a相等再按b排序。
select * from table where a= '10' oreder a,b,c; 可以使用索引。
```

### 索引是不是越多越好？
索引主要是两个缺点，一个是空间上的，一个是时间上的。
* 空间上：每个索引都会对应一棵索引B+树，每一棵B+树都要占用很多的磁盘空间，所以要是搞的索引太多了，是很耗费磁盘空间的。
* 时间上：因为每个索引B+树都要求页内是按照值大小排序的，页与页之间也是要求有序的，所以如果频繁的增删改的话,就会进行数据页的挪动 或者 页分裂，是比较耗时的。

### 索引设计原则
1. 可以设计一个或者两三个联合索引，尽量保证 where、order by、group by后续跟的字段都是联合索引的最左侧开始的部分字段，这样就都能用上索引。


1. 选择基数比较大的字段，就是值比较多的字段，这样才能发挥出B+树快速二分查找的优势。
2. 选择字段的类型比较小的字段，这样可以减少树的磁盘大小。
3. 索引不要设计太多，2、3个联合索引覆盖全部查询即可。
4. 主键一定是自增的，别用UUID之类的，因为会导致频繁的页分裂和挪动。